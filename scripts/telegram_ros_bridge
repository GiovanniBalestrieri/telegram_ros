#!/usr/bin/env python
# -*- coding: utf-8 -*-

from StringIO import StringIO

import cv2
import datetime
import numpy as np
import rospy
from cv_bridge import CvBridge
from sensor_msgs.msg import Image, NavSatFix
from std_msgs.msg import String
from telegram.error import TimedOut
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters
from telegram import Location


class TelegramROSBridge(object):
    def __init__(self, api_token, caption_as_frame_id):
        # ROS IO
        """
        Telegram ROS bridge that bridges between a telegram chat conversation and ROS        
        :param api_token: The telegram API token
        """
        self._caption_as_frame_id = caption_as_frame_id

        self._from_telegram_string_publisher = rospy.Publisher("message_to_ros", String, queue_size=10)
        self._from_telegram_image_publisher = rospy.Publisher("image_to_ros", Image, queue_size=10)
        self._from_telegram_location_publisher = rospy.Publisher("location_to_ros", NavSatFix, queue_size=10)

        self._to_telegram_string_subscriber = rospy.Subscriber("message_from_ros", String,
                                                               self._ros_string_callback, queue_size=10)
        self._to_telegram_image_subscriber = rospy.Subscriber("image_from_ros", Image,
                                                              self._ros_image_callback, queue_size=10)
        self._to_telegram_location_subscriber = rospy.Subscriber("location_from_ros", NavSatFix,
                                                              self._ros_location_callback, queue_size=10)
        # Set CvBridge
        self._cv_bridge = CvBridge()

        # Telegram IO
        self._telegram_chat_id = None
        self._telegram_updater = Updater(api_token)
        self._telegram_updater.dispatcher.add_error_handler(
            lambda _, update, error: rospy.logerr("Update {} caused error {}".format(update, error)))

        self._telegram_updater.dispatcher.add_handler(CommandHandler("start", self._telegram_start_callback))
        self._telegram_updater.dispatcher.add_handler(MessageHandler(Filters.text, self._telegram_message_callback))
        self._telegram_updater.dispatcher.add_handler(MessageHandler(Filters.photo, self._telegram_photo_callback))
        self._telegram_updater.dispatcher.add_handler(MessageHandler(Filters.location, self._telegram_location_callback))

    def spin(self):
        """
        Starts the telegram update thread and spins until a SIGINT is received
        """
        self._telegram_updater.start_polling()
        rospy.loginfo("Telegram updater started polling, spinning ..")

        rospy.spin()
        rospy.loginfo("Shutting down telegram updater ...")

        self._telegram_updater.stop()

    def _telegram_start_callback(self, _, update):
        """
        Called when a telegram user sends the '/start' event to the bot, using this event, the bridge can be connected
        to a specific conversation
        :param update: Received update event that holds the chat_id and message data 
        """
        if self._telegram_chat_id is not None and self._telegram_chat_id != update.message.chat_id:
            rospy.logwarn("Changing to different chat_id!")
            self._telegram_updater.bot.send_message(self._telegram_chat_id,
                                                    "Lost ROS bridge connection to this chat_id (somebody took over)")

        self._telegram_chat_id = update.message.chat_id

        rospy.loginfo("Starting telegram ROS bridge for chat id {}".format(self._telegram_chat_id))
        update.message.reply_text(
            "Telegram ROS bridge initialized, only replying to chat_id {} (current)".format(self._telegram_chat_id))

    def _telegram_message_callback(self, _, update):
        """
        Called when a new telegram message has been received. The method will verify whether the incoming message is
        from the bridges telegram conversation by comparing the chat_id.
        :param update: Received update that holds the chat_id and message data
        """
        text = update.message.text.encode('utf-8')
        rospy.loginfo("Incoming message from telegram: {}".format(text))
        if self._telegram_chat_id is None:
            rospy.logwarn("Discarding message. No active chat_id.")
            update.message.reply_text("ROS Bridge not initialized. Type /start to set-up ROS bridge")
        elif self._telegram_chat_id != update.message.chat_id:
            rospy.logwarn("Discarding message. Invalid chat_id")
            update.message.reply_text(
                "ROS Bridge initialized to another chat_id. Type /start to connect to this chat_id")
        else:
            self._from_telegram_string_publisher.publish(String(data=text))

    def _telegram_photo_callback(self, _, update):
        """
        Called when a new telegram photo has been received. The method will verify whether the incoming message is
        from the bridges telegram conversation by comparing the chat_id.
        :param update: Received update that holds the chat_id and message data
        """
        rospy.loginfo("Incoming photo from telegram")
        if self._telegram_chat_id is None:
            rospy.logwarn("Discarding photo. No active chat_id.")
            update.message.reply_text("ROS Bridge not initialized. Type /start to set-up ROS bridge")
        elif self._telegram_chat_id != update.message.chat_id:
            rospy.logwarn("Discarding photo. Invalid chat_id")
            update.message.reply_text(
                "ROS Bridge initialized to another chat_id. Type /start to connect to this chat_id")
        else:
            rospy.loginfo("Received image, downloading highest resolution image ...")
            byte_array = update.message.photo[-1].get_file().download_as_bytearray()
            rospy.loginfo("Download complete, publishing ...")

            img = cv2.imdecode(np.asarray(byte_array, dtype=np.uint8), cv2.IMREAD_COLOR)
            msg = self._cv_bridge.cv2_to_imgmsg(img, encoding="bgr8")

            if self._caption_as_frame_id:
                msg.header.frame_id = update.message.caption
            self._from_telegram_image_publisher.publish(msg)

            if update.message.caption:
                self._from_telegram_string_publisher.publish(String(data=update.message.caption))

    def _ros_string_callback(self, msg):
        """
        Called when a new ROS String message is coming in that should be send to the telegram conversation
        :param msg: String message
        """
        if not self._telegram_chat_id:
            rospy.logerr("ROS Bridge not initialized, dropping string message")
        else:
            try:
                self._telegram_updater.bot.send_message(self._telegram_chat_id, msg.data)
            except TimedOut as e:
                rospy.logerr("Failed to send message {}: {}".format(msg.data, e))

    def _ros_image_callback(self, msg):
        """
        Called when a new ROS Image message is coming in that should be send to the telegram conversation
        :param msg: Image message
        """
        if not self._telegram_chat_id:
            rospy.logerr("ROS Bridge not initialized, dropping image message")
        else:
            cv2_img = self._cv_bridge.imgmsg_to_cv2(msg, "bgr8")
            self._telegram_updater.bot.send_photo(self._telegram_chat_id,
                                                  photo=StringIO(cv2.imencode('.jpg', cv2_img)[1].tostring()))

    def _telegram_location_callback(self, _, update):
        """
        Called when a new telegram Location is received. The method will verify whether the incoming Location is
        from the bridges telegram conversation by comparing the chat_id.
        :param update: Received update that holds the chat_id and message data
        """
        location = update.message.location
        if isinstance(location, Location):
            rospy.loginfo("Incoming location from telegram: {}".format(location))
            if self._telegram_chat_id is None:
                rospy.logwarn("Discarding message. No active chat_id.")
                update.message.reply_text("ROS Bridge not initialized. Type /start to set-up ROS bridge")
            elif self._telegram_chat_id != update.message.chat_id:
                rospy.logwarn("Discarding message. Invalid chat_id")
                update.message.reply_text(
                    "ROS Bridge initialized to another chat_id. Type /start to connect to this chat_id")
            else:
                navsatfix = NavSatFix()
                navsatfix.header.stamp = update.message.date # TODO convert tot ROS Time
                sec_since_epoch = (update.message.date - datetime.datetime(1970,1,1)).total_seconds()
                navsatfix.header.stamp = rospy.Time.from_sec(sec_since_epoch)
                navsatfix.header.frame_id = "telegram"
                navsatfix.latitude = location.latitude
                navsatfix.longitude = location.longitude
                navsatfix.position_covariance_type = NavSatFix.COVARIANCE_TYPE_UNKNOWN
                self._from_telegram_location_publisher.publish(navsatfix)

    def _ros_location_callback(self, msg):
        """
        Called when a new ROS NavSatFix message is coming in that should be send to the telegram conversation
        :param msg: NavSatFix that the robot wants to share
        """
        if not self._telegram_chat_id:
            rospy.logerr("ROS Bridge not initialized, dropping string message")
        else:
            location = Location(msg.longitude, msg.latitude)
            try:
                self._telegram_updater.bot.send_location(self._telegram_chat_id, location=location)
            except TimedOut as e:
                rospy.logerr("Failed to send location {}: {}".format(location, e))

if __name__ == '__main__':
    rospy.init_node('telegram_ros_bridge')
    token = rospy.get_param('~token')
    caption_as_frame_id = rospy.get_param('~caption_as_frame_id', False)

    bridge = TelegramROSBridge(token, caption_as_frame_id)
    bridge.spin()
